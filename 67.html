<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Six & Seven: Ricochet Deck</title>
<style>
  :root{
    --bg:#0b0b0b;
    --hud:rgba(0,0,0,0.75);
    --panel:rgba(0,0,0,0.88);
    --card:#333;
    --card2:#222;
    --line:#444;
    --good:#0a7;
    --bad:#c33;
    --text:#fff;
    --muted:#b8b8b8;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: Arial, sans-serif;
    cursor: crosshair;
    overflow: hidden;
  }

  #hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    height: 56px;
    background: var(--hud);
    display: flex;
    align-items: center;
    gap: 18px;
    padding: 0 16px;
    z-index: 5;
    user-select: none;
  }

  #stats { white-space: nowrap; }

  #effects {
    display: flex;
    gap: 10px;
    align-items: center;
    color: var(--muted);
    font-size: 13px;
    flex: 1;
    overflow: hidden;
  }
  .pill{
    border: 1px solid var(--line);
    padding: 4px 8px;
    border-radius: 999px;
    white-space: nowrap;
    background: rgba(255,255,255,0.04);
  }

  #timer {
    height: 10px;
    width: 240px;
    background: #333;
    border-radius: 999px;
    overflow: hidden;
  }

  #timerFill {
    height: 100%;
    width: 100%;
    background: var(--good);
  }

  #arena {
    position: absolute;
    top: 56px;
    left: 0;
    right: 0;
    bottom: 110px;
  }

  .card {
    position: absolute;
    width: 70px;
    height: 70px;
    background: var(--card);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    user-select: none;
    box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset;
  }

  .card.revealed { box-shadow: 0 0 0 1px rgba(255,255,255,0.12) inset; }
  .card.ping-sticky { box-shadow: 0 0 0 2px rgba(255,255,255,0.25) inset, 0 0 18px rgba(10,255,200,0.12); }
  .card.frozen {
    box-shadow: 0 0 0 2px rgba(140,200,255,0.35) inset, 0 0 18px rgba(140,200,255,0.10);
    filter: saturate(0.85) contrast(1.05);
  }

  #hand {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 110px;
    background: var(--panel);
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    padding: 10px;
    z-index: 5;
  }

  .slot {
    border: 1px solid var(--line);
    background: rgba(255,255,255,0.03);
    border-radius: 10px;
    padding: 10px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    min-width: 0;
  }
  .slot:hover { background: rgba(255,255,255,0.05); }
  .slot.disabled { opacity: 0.45; cursor: not-allowed; }
  .slot .top {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    align-items: baseline;
  }
  .slot .name {
    font-weight: 700;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .slot .cost {
    color: var(--muted);
    white-space: nowrap;
    font-size: 12px;
  }
  .slot .desc {
    color: var(--muted);
    font-size: 12px;
    line-height: 1.2;
    margin-top: 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }

  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.92);
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 10;
    padding: 24px;
    text-align: center;
  }
  .overlay.show { display: flex; }

  .panel {
    width: min(960px, 92vw);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 14px;
    background: rgba(20,20,20,0.65);
    box-shadow: 0 25px 80px rgba(0,0,0,0.55);
    padding: 18px;
  }

  .row { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
  .row.left { justify-content: flex-start; }
  .row.between { justify-content: space-between; align-items: center; }

  h1,h2,h3,p { margin: 0; }
  h1 { font-size: 34px; }
  h2 { font-size: 20px; }
  p { color: var(--muted); margin-top: 10px; }

  button {
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    color: white;
    padding: 10px 14px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
  }
  button:hover { background: rgba(255,255,255,0.09); }
  button.primary { background: rgba(10,255,180,0.10); border-color: rgba(10,255,180,0.22); }
  button.danger { background: rgba(255,60,60,0.08); border-color: rgba(255,60,60,0.22); }
  button:disabled { opacity: 0.5; cursor: not-allowed; }

  .shop-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    margin-top: 14px;
  }
  @media (max-width: 820px){
    .shop-grid{ grid-template-columns: 1fr; }
  }

  .shop-box {
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 12px;
    padding: 12px;
    background: rgba(255,255,255,0.03);
    text-align: left;
  }

  .shop-card {
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 12px;
    padding: 12px;
    background: rgba(255,255,255,0.03);
    text-align: left;
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    align-items: center;
  }
  .shop-card h3 { font-size: 16px; margin-bottom: 4px; }
  .shop-card .meta { color: var(--muted); font-size: 12px; }
  .shop-card .meta b { color: #fff; }
  .shop-card .desc { color: var(--muted); font-size: 12px; margin-top: 8px; }

  .tiny { font-size: 12px; color: var(--muted); }

  .divider {
    height: 1px;
    background: rgba(255,255,255,0.10);
    margin: 14px 0;
  }
</style>
</head>
<body>

<div id="hud">
  <div id="stats"></div>
  <div id="effects"></div>
  <div id="timer"><div id="timerFill"></div></div>
</div>

<div id="arena"></div>
<div id="hand"></div>

<!-- MENU -->
<div class="overlay show" id="menuOverlay">
  <div class="panel">
    <h1>Six & Seven</h1>
    <p>Find the 6 and the 7. Match them. Donâ€™t run out of time. Donâ€™t die.</p>
    <div class="divider"></div>
    <div class="row" style="flex-direction:column; align-items:center; gap:12px;">
      <button class="primary" id="playBtn">Play</button>
      <button id="cageBtn"></button>
    </div>
    <p class="tiny" style="margin-top:14px;">Tip: Action cards are your whole personality now.</p>
  </div>
</div>

<!-- END OF ROUND -->
<div class="overlay" id="endOverlay">
  <div class="panel">
    <h1 id="endTitle"></h1>
    <p id="endSub"></p>
    <div class="divider"></div>
    <div class="row" style="justify-content:center;">
      <button class="primary" id="toShopBtn">Shop</button>
      <button id="nextBtn">Next Round</button>
      <button class="danger" id="menuBtn">Menu</button>
    </div>
  </div>
</div>

<!-- SHOP -->
<div class="overlay" id="shopOverlay">
  <div class="panel">
    <div class="row between">
      <div>
        <h2>Shop</h2>
        <p class="tiny" id="shopTopLine"></p>
      </div>
      <div class="row" style="justify-content:flex-end; gap:10px;">
        <button id="shopTabActions" class="primary">Actions</button>
        <button id="shopTabDeck">Deck</button>
        <button id="shopTabSettings">Settings</button>
        <button id="skipShopBtn">Done</button>
      </div>
    </div>

    <div class="divider"></div>

    <!-- ACTIONS TAB -->
    <div id="shopPanelActions">
      <div class="shop-grid">
        <div class="shop-box">
          <h3>Your 4 Action Slots</h3>
          <p class="tiny">Sell any card to make room. Empty slots are buyable.</p>
          <div class="divider"></div>
          <div id="loadoutList" class="row left" style="flex-direction:column; gap:10px;"></div>
        </div>

        <div class="shop-box">
          <h3>For Sale (3)</h3>
          <p class="tiny">Only actions you donâ€™t already own appear here.</p>
          <div class="divider"></div>
          <div id="shopOffers" class="row left" style="flex-direction:column; gap:10px;"></div>
        </div>
      </div>
    </div>

    <!-- DECK TAB -->
    <div id="shopPanelDeck" style="display:none;">
      <div class="shop-grid">
        <div class="shop-box">
          <h3>Your 5 Deck Additions</h3>
          <p class="tiny">These replace default filler glyphs in the board deck.</p>
          <div class="divider"></div>
          <div id="deckList" class="row left" style="flex-direction:column; gap:10px;"></div>
        </div>

        <div class="shop-box">
          <h3>Deck Cards For Sale</h3>
          <p class="tiny">Buy adds a deck card into an empty deck slot.</p>
          <div class="divider"></div>
          <div id="deckOffers" class="row left" style="flex-direction:column; gap:10px;"></div>
        </div>
      </div>
    </div>

    <!-- SETTINGS TAB -->
    <div id="shopPanelSettings" style="display:none;">
      <div class="shop-box" style="max-width:760px; margin: 0 auto;">
        <h3>Timer Settings</h3>
        <p class="tiny">Change the base round timer. (Saved automatically.)</p>
        <div class="divider"></div>

        <div class="row left" style="align-items:center; gap:14px;">
          <div style="min-width:220px;">Base timer (seconds): <b id="baseTimerReadout"></b></div>
          <input id="baseTimerSlider" type="range" min="8" max="60" step="1" style="width:min(420px, 70vw);" />
          <button id="baseTimerResetBtn">Reset</button>
        </div>

        <p class="tiny" style="margin-top:12px;">
          Round time = base timer minus a small amount each round (difficulty ramp). Minimum is still enforced.
        </p>
      </div>
    </div>
  </div>
</div>


<script>
/* =========================
   Core Elements
========================= */
const arena = document.getElementById('arena');
const handDiv = document.getElementById('hand');
const statsDiv = document.getElementById('stats');
const effectsDiv = document.getElementById('effects');
const timerFill = document.getElementById('timerFill');

const menuOverlay = document.getElementById('menuOverlay');
const endOverlay = document.getElementById('endOverlay');
const shopOverlay = document.getElementById('shopOverlay');

const playBtn = document.getElementById('playBtn');
const cageBtn = document.getElementById('cageBtn');

const endTitle = document.getElementById('endTitle');
const endSub = document.getElementById('endSub');
const toShopBtn = document.getElementById('toShopBtn');
const nextBtn = document.getElementById('nextBtn');
const menuBtn = document.getElementById('menuBtn');

const shopTopLine = document.getElementById('shopTopLine');
const loadoutList = document.getElementById('loadoutList');
const shopOffers = document.getElementById('shopOffers');
const skipShopBtn = document.getElementById('skipShopBtn');

// Shop tabs
const shopTabActions = document.getElementById('shopTabActions');
const shopTabDeck = document.getElementById('shopTabDeck');
const shopTabSettings = document.getElementById('shopTabSettings');

const shopPanelActions = document.getElementById('shopPanelActions');
const shopPanelDeck = document.getElementById('shopPanelDeck');
const shopPanelSettings = document.getElementById('shopPanelSettings');

// Deck shop UI
const deckList = document.getElementById('deckList');
const deckOffers = document.getElementById('deckOffers');

// Settings UI
const baseTimerReadout = document.getElementById('baseTimerReadout');
const baseTimerSlider = document.getElementById('baseTimerSlider');
const baseTimerResetBtn = document.getElementById('baseTimerResetBtn');


/* =========================
   Game State
========================= */
let round = 1;
let hp = 15;
let energy = 3;
let credits = 0;

let cards = [];
let firstPick = null;
let lockClicks = false;
let slowFactor = 1;
let animation;
let timeLeft;
let timerInterval;

let pingCharges = 0;       // NEXT 3 clicks become sticky revealed for the rest of the round
let lockOnArmed = false;   // Next clicked target becomes frozen for the rest of the round

let pendingNextAction = null; // "advance" or "retry" or "menu" used after shop

  // Timer settings (base time is user-adjustable)
let baseTimerSeconds = Number(localStorage.getItem('baseTimerSeconds') || 22); // slower default
const minBaseTimer = 8;
const maxBaseTimer = 60;

function roundTimeTotal() {
  // Gradual difficulty ramp; still respects the base timer
  const total = baseTimerSeconds - (round - 1) * 0.6;
  return Math.max(6, total);
}

function saveTimerSetting() {
  localStorage.setItem('baseTimerSeconds', String(baseTimerSeconds));
}


const falseGlyphs = ['âŸŸ','â§—','âŒ¶','âŸ','âŸŠ','â§–','âŸ','â§‹','â§Ž','âŒ','âŸ°','âŸ±'];

/* =========================
   Action Cards (9 total)
   - 4 slots active
   - Shop sells random 3 each round
========================= */
const ACTIONS = {
  stabilize: {
    id: 'stabilize',
    name: 'Stabilize',
    cost: 1,
    shopCost: 4,
    sellValue: 2,
    desc: 'Slow all motion for 3s.',
    play: () => slowTemporarily()
  },
  ping: {
    id: 'ping',
    name: 'Ping',
    cost: 2,
    shopCost: 6,
    sellValue: 3,
    desc: 'Your next 3 clicks stay revealed for the rest of the round.',
    play: () => armPing()
  },
  lockon: {
    id: 'lockon',
    name: 'Lock-On',
    cost: 2,
    shopCost: 6,
    sellValue: 3,
    desc: 'Next clicked target is frozen for the rest of the round.',
    play: () => armLockOn()
  },
  scramble: {
    id: 'scramble',
    name: 'Scramble',
    cost: 1,
    shopCost: 5,
    sellValue: 2,
    desc: 'Randomize all velocities right now.',
    play: () => scramble()
  },

  // 5 new cards
  scan: {
    id: 'scan',
    name: 'Scan',
    cost: 2,
    shopCost: 7,
    sellValue: 3,
    desc: 'Reveal ALL cards for 1.2s (not sticky).',
    play: () => scanAll()
  },
  burst: {
    id: 'burst',
    name: 'Burst',
    cost: 1,
    shopCost: 5,
    sellValue: 2,
    desc: 'Freeze EVERYTHING for 1.6s.',
    play: () => freezeAllBrief()
  },
  focus: {
    id: 'focus',
    name: 'Focus',
    cost: 1,
    shopCost: 4,
    sellValue: 2,
    desc: 'Add +1 energy (once per round).',
    play: () => gainEnergyOnce()
  },
  heal: {
    id: 'heal',
    name: 'Patch',
    cost: 2,
    shopCost: 8,
    sellValue: 4,
    desc: 'Heal +2 HP (max 15).',
    play: () => healPlayer()
  },
  pulse: {
    id: 'pulse',
    name: 'Pulse',
    cost: 1,
    shopCost: 6,
    sellValue: 3,
    desc: 'Shuffle the board positions instantly.',
    play: () => pulsePositions()
  }
};

const ALL_ACTION_IDS = Object.keys(ACTIONS);

let loadout = [null,null,null,null]; // 4 action slots (start with 1 random later)
let shopPool = [];

// Deck additions (5 slots)
const DECK_CARDS = {
  money: { id:'money', name:'Cash Cache', shopCost: 8, sellValue: 4, count: 4, desc:'Adds 4 money cards into the deck. Clicking one grants +2 credits.' },
  energy:{ id:'energy', name:'Battery',   shopCost: 7, sellValue: 3, count: 3, desc:'Adds 3 energy cards into the deck. Clicking one grants +1 energy.' },
  reveal:{ id:'reveal', name:'All-Scan',  shopCost: 9, sellValue: 4, count: 2, desc:'Adds 2 scan cards into the deck. Clicking one reveals all cards briefly.' },
  heal:  { id:'heal',   name:'Med Patch', shopCost:10, sellValue: 5, count: 4, desc:'Adds 4 heal cards into the deck. Clicking one heals +1 HP (max 15).' }
};
const ALL_DECK_IDS = Object.keys(DECK_CARDS);

let deckLoadout = [null,null,null,null,null]; // 5 deck slots
let deckShopPool = []; // offers (all 4 types)


/* per-round one-time effect flags */
let focusUsedThisRound = false;

/* =========================
   Menu + Cage button
========================= */
const randomWords = [
  'Wombat','Eclipse','Tarmac','Velvet','Petrichor','Anvil','Caper','Mongoose','Nimbus','Cinnamon',
  'Goblin','Quartz','Spatula','Yonder','Lullaby','Mistral','Gizmo','Rhubarb','Pilgrim','Banjo'
];
const NIC_CAGE_IMAGE = 'https://commons.wikimedia.org/wiki/Special:FilePath/Nicolas_Cage_cropped_2009.jpg';

function setCageButtonLabel(){
  const w = randomWords[Math.floor(Math.random()*randomWords.length)];
  cageBtn.textContent = w;
}

playBtn.onclick = () => {
  showMenu(false);
  newRun();
};

cageBtn.onclick = () => {
  window.location.href = NIC_CAGE_IMAGE;
};

function showMenu(on){
  menuOverlay.classList.toggle('show', !!on);
  endOverlay.classList.remove('show');
  shopOverlay.classList.remove('show');

  // Hide playfield when menu is up
  const showGame = !on;
  document.getElementById('hud').style.display = showGame ? 'flex' : 'none';
  arena.style.display = showGame ? 'block' : 'none';
  handDiv.style.display = showGame ? 'grid' : 'none';
}

/* =========================
   Run setup
========================= */
setCageButtonLabel();
showMenu(true);

/* =========================
   Round Flow
========================= */
function newRun(){
  cancelAnimationFrame(animation);
  clearInterval(timerInterval);

  round = 1;
  hp = 15;
  credits = 0;

  // Start with exactly 1 random action, other slots empty
loadout = [null,null,null,null];
const first = ALL_ACTION_IDS[Math.floor(Math.random() * ALL_ACTION_IDS.length)];
loadout[0] = first;

deckLoadout = [null,null,null,null,null]; // start with no deck additions

startRound();

}

function startRound() {
  cancelAnimationFrame(animation);
  clearInterval(timerInterval);

  endOverlay.classList.remove('show');
  shopOverlay.classList.remove('show');

  arena.innerHTML = '';
  cards = [];
  firstPick = null;
  lockClicks = false;
  slowFactor = 1;
  energy = 3;

  pingCharges = 0;
  lockOnArmed = false;
  focusUsedThisRound = false;

  timeLeft = roundTimeTotal();
  startTimer();

  drawLoadoutBar();

  // Build deck: 6/7 + filler glyphs, but replace some filler with deck additions
const additions = [];

deckLoadout.filter(Boolean).forEach(id => {
  const def = DECK_CARDS[id];
  for (let i=0; i<def.count; i++) additions.push(id);
});

// Start with 6/7 + additions + filler to reach 16
const base = ['6','7', ...additions];
const fillerNeeded = Math.max(0, 16 - base.length);
const filler = shuffle([...falseGlyphs]).slice(0, fillerNeeded);

const values = shuffle([...base, ...filler]).slice(0,16);
values.forEach(v => spawnCard(v));


  animate();
  updateUI();
}

function startTimer() {
  const total = roundTimeTotal();
  timerFill.style.width = '100%';
  timerInterval = setInterval(() => {
    timeLeft -= 0.1;
    const pct = Math.max(0, (timeLeft / total) * 100);
    timerFill.style.width = `${pct}%`;
    if (timeLeft <= 0) endRound(false, 'Too Slow', '-3 HP');
  }, 100);
}

function endRound(win, title, sub){
  clearInterval(timerInterval);

  if (!win){
    hp -= 3;
    if (hp <= 0){
      hp = 0;
      title = 'Run Over';
      sub = 'HP hit 0.';
    }
  } else {
    round++;
  }

  // Credits payout (simple + deterministic)
  // Win: +6, Lose but alive: +3, Death: +0
  if (win) credits += 6;
  else if (hp > 0) credits += 3;

  pendingNextAction = (hp <= 0) ? 'menu' : (win ? 'advance' : 'retry');

  endTitle.textContent = title;
  endSub.textContent = `${sub}  |  Credits: ${credits}`;

  // End overlay always shown; shop is available every round end.
  endOverlay.classList.add('show');

  // Button availability
  menuBtn.style.display = 'inline-block';
  nextBtn.textContent = (pendingNextAction === 'advance') ? 'Next Round' : 'Retry Round';
  nextBtn.style.display = (pendingNextAction === 'menu') ? 'none' : 'inline-block';

  updateUI();
}

/* End overlay buttons */
toShopBtn.onclick = () => openShop();
nextBtn.onclick = () => {
  endOverlay.classList.remove('show');
  if (pendingNextAction === 'advance' || pendingNextAction === 'retry') startRound();
};
menuBtn.onclick = () => {
  cancelAnimationFrame(animation);
  clearInterval(timerInterval);
  showMenu(true);
};

/* Shop */
skipShopBtn.onclick = () => {
  shopOverlay.classList.remove('show');
  endOverlay.classList.remove('show');

  if (pendingNextAction === 'menu'){
    showMenu(true);
  } else {
    startRound();
  }
};
  shopTabActions.onclick = () => setShopTab('actions');
shopTabDeck.onclick = () => setShopTab('deck');
shopTabSettings.onclick = () => setShopTab('settings');

function setShopTab(which){
  shopPanelActions.style.display = (which === 'actions') ? 'block' : 'none';
  shopPanelDeck.style.display = (which === 'deck') ? 'block' : 'none';
  shopPanelSettings.style.display = (which === 'settings') ? 'block' : 'none';

  shopTabActions.classList.toggle('primary', which === 'actions');
  shopTabDeck.classList.toggle('primary', which === 'deck');
  shopTabSettings.classList.toggle('primary', which === 'settings');

  // refresh settings UI when opened
  if (which === 'settings') renderSettings();
}

function renderSettings(){
  baseTimerSlider.min = String(minBaseTimer);
  baseTimerSlider.max = String(maxBaseTimer);
  baseTimerSlider.value = String(baseTimerSeconds);
  baseTimerReadout.textContent = String(baseTimerSeconds);

  baseTimerSlider.oninput = () => {
    baseTimerSeconds = Number(baseTimerSlider.value);
    baseTimerReadout.textContent = String(baseTimerSeconds);
    saveTimerSetting();
  };

  baseTimerResetBtn.onclick = () => {
    baseTimerSeconds = 22;
    baseTimerSlider.value = String(baseTimerSeconds);
    baseTimerReadout.textContent = String(baseTimerSeconds);
    saveTimerSetting();
  };
}


function openShop(){
  endOverlay.classList.remove('show');
  shopOverlay.classList.add('show');

  // Action offers: 3 random actions NOT already owned
  const owned = new Set(loadout.filter(Boolean));
  const candidates = ALL_ACTION_IDS.filter(id => !owned.has(id));
  const ids = shuffle([...candidates]).slice(0,3);
  shopPool = ids.map(id => ACTIONS[id]);

  // Deck offers: fixed set (money/energy/reveal/heal)
  deckShopPool = ALL_DECK_IDS.map(id => DECK_CARDS[id]);

  // Default tab
  setShopTab('actions');
  renderShop();
}


function renderShop(){
  shopTopLine.textContent = `Round ended. Credits: ${credits}.`;

  // Loadout list (4 slots)
  loadoutList.innerHTML = '';
  for (let i=0; i<4; i++){
    const id = loadout[i] || null;

    const box = document.createElement('div');
    box.className = 'shop-card';

    const left = document.createElement('div');
    const right = document.createElement('div');

    if (id){
      const a = ACTIONS[id];
      left.innerHTML = `
        <h3>${escapeHTML(a.name)}</h3>
        <div class="meta">Play cost: <b>${a.cost}</b> energy Â· Sell: <b>${a.sellValue}</b> credits</div>
        <div class="desc">${escapeHTML(a.desc)}</div>
      `;
      const sell = document.createElement('button');
      sell.className = 'danger';
      sell.textContent = 'Sell';
      sell.onclick = () => {
        credits += a.sellValue;
        loadout[i] = null;
        compactLoadout();
        renderShop();
        updateUI();
      };
      right.appendChild(sell);
    } else {
      left.innerHTML = `
        <h3>(Empty Slot)</h3>
        <div class="meta">Buy something to fill this slot.</div>
        <div class="desc">No card equipped.</div>
      `;
      const noop = document.createElement('button');
      noop.disabled = true;
      noop.textContent = 'Empty';
      right.appendChild(noop);
    }

    box.appendChild(left);
    box.appendChild(right);
    loadoutList.appendChild(box);
  }

  // Offers
  shopOffers.innerHTML = '';
  shopPool.forEach((a) => {
    const box = document.createElement('div');
    box.className = 'shop-card';

    const left = document.createElement('div');
    left.innerHTML = `
      <h3>${escapeHTML(a.name)}</h3>
      <div class="meta">Play cost: <b>${a.cost}</b> energy Â· Price: <b>${a.shopCost}</b> credits</div>
      <div class="desc">${escapeHTML(a.desc)}</div>
    `;

    const right = document.createElement('div');
    const buy = document.createElement('button');
    buy.className = 'primary';
    buy.textContent = 'Buy';

    const emptyIndex = loadout.findIndex(x => !x);
    const canAfford = credits >= a.shopCost;
    const hasSlot = emptyIndex !== -1;

    buy.disabled = !(canAfford && hasSlot);

    buy.onclick = () => {
      if (credits < a.shopCost) return;
      const idx = loadout.findIndex(x => !x);
      if (idx === -1) return;

      credits -= a.shopCost;
      loadout[idx] = a.id;

      // Remove purchased offer from shop (optional but nicer)
      shopPool = shopPool.filter(x => x.id !== a.id);
      renderShop();
      updateUI();
    };

    right.appendChild(buy);
    box.appendChild(left);
    box.appendChild(right);
    shopOffers.appendChild(box);
  });
    // Deck loadout (5 slots)
  deckList.innerHTML = '';
  for (let i=0; i<5; i++){
    const id = deckLoadout[i] || null;

    const box = document.createElement('div');
    box.className = 'shop-card';

    const left = document.createElement('div');
    const right = document.createElement('div');

    if (id){
      const d = DECK_CARDS[id];
      left.innerHTML = `
        <h3>${escapeHTML(d.name)}</h3>
        <div class="meta">Adds: <b>${d.count}</b> cards Â· Sell: <b>${d.sellValue}</b> credits</div>
        <div class="desc">${escapeHTML(d.desc)}</div>
      `;
      const sell = document.createElement('button');
      sell.className = 'danger';
      sell.textContent = 'Sell';
      sell.onclick = () => {
        credits += d.sellValue;
        deckLoadout[i] = null;
        compactDeckLoadout();
        renderShop();
        updateUI();
      };
      right.appendChild(sell);
    } else {
      left.innerHTML = `
        <h3>(Empty Slot)</h3>
        <div class="meta">Buy a deck card to fill this slot.</div>
        <div class="desc">No deck addition equipped.</div>
      `;
      const noop = document.createElement('button');
      noop.disabled = true;
      noop.textContent = 'Empty';
      right.appendChild(noop);
    }

    box.appendChild(left);
    box.appendChild(right);
    deckList.appendChild(box);
  }

  // Deck offers (all 4 types)
  deckOffers.innerHTML = '';
  deckShopPool.forEach((d) => {
    const box = document.createElement('div');
    box.className = 'shop-card';

    const left = document.createElement('div');
    left.innerHTML = `
      <h3>${escapeHTML(d.name)}</h3>
      <div class="meta">Adds: <b>${d.count}</b> cards Â· Price: <b>${d.shopCost}</b> credits</div>
      <div class="desc">${escapeHTML(d.desc)}</div>
    `;

    const right = document.createElement('div');
    const buy = document.createElement('button');
    buy.className = 'primary';
    buy.textContent = 'Buy';

    const emptyIndex = deckLoadout.findIndex(x => !x);
    const canAfford = credits >= d.shopCost;
    const hasSlot = emptyIndex !== -1;

    buy.disabled = !(canAfford && hasSlot);

    buy.onclick = () => {
      if (credits < d.shopCost) return;
      const idx = deckLoadout.findIndex(x => !x);
      if (idx === -1) return;

      credits -= d.shopCost;
      deckLoadout[idx] = d.id;

      renderShop();
      updateUI();
    };

    right.appendChild(buy);
    box.appendChild(left);
    box.appendChild(right);
    deckOffers.appendChild(box);
  });

}

function compactLoadout(){
  loadout = loadout.filter(Boolean);
  while (loadout.length < 4) loadout.push(null);
}
  function compactDeckLoadout(){
  deckLoadout = deckLoadout.filter(Boolean);
  while (deckLoadout.length < 5) deckLoadout.push(null);
}


/* =========================
   Board + Cards
========================= */
function spawnCard(value) {
  const el = document.createElement('div');
  el.className = 'card';
  arena.appendChild(el);

  const c = {
    el,
    value,
    revealed: false,
    stickyRevealed: false, // from Ping
    frozen: false,
    x: Math.random() * (arena.clientWidth - 70),
    y: Math.random() * (arena.clientHeight - 70),
    vx: randVel(),
    vy: randVel()
  };

  el.onclick = () => clickTarget(c);
  cards.push(c);
}

function clickTarget(c) {
  if (lockClicks) return;

  // If this is a deck addition card, resolve it immediately and remove it.
  if (isDeckCard(c.value)) {
    reveal(c);
    resolveDeckCard(c);
    return;
  }

  // Lock-On: next chosen target is frozen for the rest of the round.
  if (lockOnArmed){
    lockOnArmed = false;
    c.frozen = true;
    c.el.classList.add('frozen');
  }

  // Reveal on click
  reveal(c);

  // Ping: next 3 clicks become sticky revealed for the rest of the round
  if (pingCharges > 0){
    pingCharges--;
    c.stickyRevealed = true;
    c.el.classList.add('ping-sticky');
  }

  // Normal match logic (but sticky cards never hide)
  if (!firstPick) {
    firstPick = c;
    updateUI();
    return;
  }

  lockClicks = true;

  const ok =
    (firstPick.value === '6' && c.value === '7') ||
    (firstPick.value === '7' && c.value === '6');

  if (ok){
    endRound(true, 'Round Clear', '+0 HP');
    lockClicks = false;
    return;
  }

  setTimeout(() => {
    if (firstPick && !firstPick.stickyRevealed) hide(firstPick);
    if (!c.stickyRevealed) hide(c);

    firstPick = null;
    lockClicks = false;
    updateUI();
  }, 700);

  updateUI();
}


  // Reveal on click
  reveal(c);

  // Ping: next 3 clicks become sticky revealed for the rest of the round
  if (pingCharges > 0){
    pingCharges--;
    c.stickyRevealed = true;
    c.el.classList.add('ping-sticky');
  }

  // Normal match logic (but sticky cards never hide)
  if (!firstPick) {
    firstPick = c;
    updateUI();
    return;
  }

  lockClicks = true;

  const ok =
    (firstPick.value === '6' && c.value === '7') ||
    (firstPick.value === '7' && c.value === '6');

  if (ok){
    endRound(true, 'Round Clear', '+0 HP');
    lockClicks = false;
    return;
  }

  setTimeout(() => {
    if (firstPick && !firstPick.stickyRevealed) hide(firstPick);
    if (!c.stickyRevealed) hide(c);

    firstPick = null;
    lockClicks = false;
    updateUI();
  }, 700);

  updateUI();
}

function animate() {
  const w = arena.clientWidth;
  const h = arena.clientHeight;

  cards.forEach(c => {
    if (c.frozen) return;

    c.x += c.vx * slowFactor;
    c.y += c.vy * slowFactor;

    if (c.x < 0) { c.x = 0; c.vx *= -1; }
    if (c.x > w - 70) { c.x = w - 70; c.vx *= -1; }
    if (c.y < 0) { c.y = 0; c.vy *= -1; }
    if (c.y > h - 70) { c.y = h - 70; c.vy *= -1; }

    c.el.style.transform = `translate(${c.x}px,${c.y}px)`;
  });

  animation = requestAnimationFrame(animate);
}

/* =========================
   Actions (implementations)
========================= */
function armPing(){
  pingCharges = 3;
}

function armLockOn(){
  lockOnArmed = true;
}

function scramble() {
  cards.forEach(c => {
    c.vx = randVel();
    c.vy = randVel();
  });
}

function slowTemporarily() {
  slowFactor = 0.4;
  setTimeout(() => slowFactor = 1, 3000);
}

function scanAll(){
  const was = cards.map(c => ({ c, revealed: c.revealed }));
  cards.forEach(c => reveal(c));
  setTimeout(() => {
    was.forEach(({c, revealed}) => {
      // don't hide sticky-revealed (Ping)
      if (!revealed && !c.stickyRevealed) hide(c);
    });
  }, 1200);
}

function freezeAllBrief(){
  const prev = cards.map(c => ({ c, frozen: c.frozen }));
  cards.forEach(c => { c.frozen = true; c.el.classList.add('frozen'); });
  setTimeout(() => {
    prev.forEach(({c, frozen}) => {
      c.frozen = frozen;
      if (!c.frozen) c.el.classList.remove('frozen');
    });
  }, 1600);
}

function gainEnergyOnce(){
  if (focusUsedThisRound) return;
  focusUsedThisRound = true;
  energy += 1;
}

function healPlayer(){
  hp = Math.min(15, hp + 2);
}

function pulsePositions(){
  const w = arena.clientWidth;
  const h = arena.clientHeight;
  cards.forEach(c => {
    c.x = Math.random() * (w - 70);
    c.y = Math.random() * (h - 70);
    c.el.style.transform = `translate(${c.x}px,${c.y}px)`;
  });
}

/* =========================
   UI (4 slots)
========================= */
function drawLoadoutBar() {
  handDiv.innerHTML = '';
  compactLoadout();

  for (let i=0; i<4; i++){
    const id = loadout[i];
    const a = id ? ACTIONS[id] : null;

    const d = document.createElement('div');
    d.className = 'slot';

    if (!a){
      d.classList.add('disabled');
      d.innerHTML = `
        <div class="top">
          <div class="name">(Empty)</div>
          <div class="cost">â€”</div>
        </div>
        <div class="desc">Fill this slot in the Shop.</div>
      `;
      handDiv.appendChild(d);
      continue;
    }

    d.innerHTML = `
      <div class="top">
        <div class="name">${escapeHTML(a.name)}</div>
        <div class="cost">${a.cost}âš¡</div>
      </div>
      <div class="desc">${escapeHTML(a.desc)}</div>
    `;

    d.onclick = () => {
      if (energy < a.cost) return;
      // special one-time energy card should still cost energy (as defined) and is gated in play()
      energy -= a.cost;
      a.play();
      updateUI();
    };

    handDiv.appendChild(d);
  }
}

function updateUI() {
  statsDiv.textContent = `HP: ${hp} | Round: ${round} | Energy: ${energy} | Credits: ${credits}`;

  const pills = [];
  if (pingCharges > 0) pills.push(`Ping: ${pingCharges} click${pingCharges===1?'':'s'} left`);
  if (lockOnArmed) pills.push('Lock-On: armed');
  if (slowFactor < 1) pills.push('Stabilize: active');
  if (focusUsedThisRound) pills.push('Focus: used');

  effectsDiv.innerHTML = '';
  pills.forEach(t => {
    const s = document.createElement('span');
    s.className = 'pill';
    s.textContent = t;
    effectsDiv.appendChild(s);
  });

  // refresh slot disabled styling based on energy
  [...handDiv.children].forEach((node, idx) => {
    const id = loadout[idx];
    const a = id ? ACTIONS[id] : null;
    if (!a) return;
    node.classList.toggle('disabled', energy < a.cost);
  });
}

/* =========================
   Reveal / Hide
========================= */
function reveal(c) {
  c.revealed = true;
  c.el.classList.add('revealed');
  c.el.textContent = isDeckCard(c.value)
  ? (c.value === 'money' ? '$' : c.value === 'energy' ? 'âš¡' : c.value === 'reveal' ? 'ðŸ‘' : 'âœš')
  : c.value;

  c.el.style.background = randomColor();
}

function hide(c) {
  c.revealed = false;
  c.el.classList.remove('revealed');
  // don't remove ping-sticky class here; sticky reveal means it stays revealed
  c.el.textContent = '';
  c.el.style.background = '';
}

/* =========================
   Helpers
========================= */
  function isDeckCard(v){
  return v === 'money' || v === 'energy' || v === 'reveal' || v === 'heal';
}

function resolveDeckCard(c){
  // Apply effect
  if (c.value === 'money') credits += 2;
  if (c.value === 'energy') energy += 1;
  if (c.value === 'reveal') scanAll();
  if (c.value === 'heal') hp = Math.min(15, hp + 1);

  // Remove from board so it canâ€™t be farmed
  removeCardFromBoard(c);

  updateUI();
}

function removeCardFromBoard(c){
  // detach click
  c.el.onclick = null;

  // Remove from DOM and state
  try { c.el.remove(); } catch(e) {}
  cards = cards.filter(x => x !== c);

  // If it was firstPick, clear it
  if (firstPick === c) firstPick = null;
}

function randVel() {
  return (Math.random() * 2 + 1) * (Math.random() < 0.5 ? -1 : 1);
}

function randomColor() {
  return `hsl(${Math.random()*360},80%,50%)`;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function escapeHTML(s){
  return String(s)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

/* =========================
   Hooks to end round
========================= */
function winRound(){ endRound(true, 'Round Clear', '+0 HP'); }
function loseRound(){ endRound(false, 'Too Slow', '-3 HP'); }

/* When player makes a wrong match, no HP loss; time loss handles HP loss */
</script>

</body>
</html>

